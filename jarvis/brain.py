# Directory structure to apply:
# jarvis/
# ├── __init__.py
# ├── jarvis.py         # entry point
# ├── brain.py
# ├── memory.py
# ├── nlu.py
# ├── processors.py
# ├── commands.py
# ├── modules.py
# ├── project.py
# └── utils.py

# jarvis/brain.py
from collections import deque
from .processors import (
    LogicalThoughtProcessor,
    CreativeThoughtProcessor,
    AnalyticalThoughtProcessor,
    RefactorProcessor,
    TestGeneratorProcessor,
    APIBuilderProcessor,
)
from typing import Any, Dict
import logging
import time
import uuid

logger = logging.getLogger("Jarvis.Brain")

class Brain:
    def __init__(self, jarvis):
        self.jarvis = jarvis
        self.working_memory = {}
        self.reasoning_history: deque = deque(maxlen=50)
        self.thought_processors = {
            "logical": LogicalThoughtProcessor(),
            "creative": CreativeThoughtProcessor(),
            "analytical": AnalyticalThoughtProcessor(),
            "refactor": RefactorProcessor(),
            "test_generation": TestGeneratorProcessor(),
            "api_builder": APIBuilderProcessor(),
        }

    async def think(self, problem, context):
        problem_type = await self._classify_problem(problem, context)
        processor = self.thought_processors.get(problem_type, self.thought_processors["logical"])
        self.working_memory.update({"current_problem": problem, "current_context": context})
        try:
            solution = await processor.process(problem, context)
        except Exception as e:
            solution = {"error": str(e), "status": "processing_failed", "processed_by": processor.__class__.__name__}
        solution["problem_classification_used"] = problem_type

        plan = self._make_plan(problem, solution)
        code = self._generate_code(plan)

        solution["plan"] = plan
        solution["generated_code"] = code

        self._update_long_term_memory(problem, solution)
        self.working_memory.clear()
        return solution

    async def _classify_problem(self, problem, context):
        p = problem.lower()
        if any(x in p for x in ["проанализируй", "сравни", "статистика", "данные"]):
            return "analytical"
        if "рефактор" in p:
            return "refactor"
        if "тест" in p:
            return "test_generation"
        if "api" in p or "веб-сервис" in p:
            return "api_builder"
        if any(x in p for x in ["создай", "придумай", "идея"]):
            return "creative"
        if any(x in p for x in ["если", "как", "что если", "объясни"]):
            return "logical"
        return context.get("preferred_processor", "logical")

    def _update_long_term_memory(self, problem, solution):
        memory_key = f"brain.thoughts.{uuid.uuid5(uuid.NAMESPACE_DNS, problem).hex}"
        record = {
            "problem": problem,
            "solution": solution,
            "timestamp": time.time(),
        }
        self.jarvis.memory.remember(memory_key, record, category="reasoning")
        history = self.jarvis.memory.recall("brain.reasoning_history") or []
        history.append(record)
        if len(history) > 50:
            history = history[-50:]
        self.jarvis.memory.remember("brain.reasoning_history", history, category="reasoning")
        self.reasoning_history.append(record)

    def _make_plan(self, problem: str, solution: Dict[str, Any]) -> Dict[str, Any]:
        """Create a tiny plan based on the problem and solution."""
        return {"steps": [f"Разобрать задачу: {problem[:30]}", "Подготовить код"]}

    def _generate_code(self, plan: Dict[str, Any]) -> str:
        """Return placeholder code based on plan."""
        if not plan:
            return ""
        return "# code generated by Brain\n"
